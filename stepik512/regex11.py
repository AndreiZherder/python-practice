"""
Примечание:
Эта задача является дополнительной, то есть ее решение не принесет вам баллы.
Задача сложнее остальных задач из этого раздела,
и идея ее решения выходит за рамки простого понимания регулярных выражений как средства задания шаблона строки.
Мы решили включить данную задачу в урок, чтобы показать,
что регулярным выражением можно проверить не только "внешний вид" строки, но и заложенный в ней смысл.


Вам дана последовательность строк.
Выведите строки, содержащие двоичную запись числа, кратного 3.

Двоичной записью числа называется его запись в двоичной системе счисления.

Примечание 2:
Данная задача очень просто может быть решена приведением строки к целому числу и проверке остатка от деления на три,
но мы все же предлагаем вам решить ее, не используя приведение к числу.
Sample Input:

0
10010
00101
01001
Not a number
1 1
0 0


Sample Output:

0
10010
01001
"""
import re
import sys


def generate_numbers():
    with open('../data/out1.txt', 'w') as out_file:
        l = [[9 * j + i for j in range(11)] for i in range(9)]
        for i in range(9):
            for j in range(11):
                out_file.write(f'{l[i][j]:08b} ')
            out_file.write('\n')


def main():
    """
    Хорошая задача, которая помогает разобраться, как алгоритмически работают регулярные выражения,
    как проверяется соответствие строки шаблону.

    Положим мы имеем число, делящееся на 3 без остатка.
    Приписывание 0 к бинарной записи числа справа равносильно умножению его на 2 (n = 2 * n).
    2 * n делится на 3 без остатка, так как n делится на 3 без остатка.
    Таким, образом, при добавлении любого количества нулей справа результат будет делится на 3.
    Приписывание 1 к бинарной записи числа справа равносильно умножению его на 2 и прибавлению 1 (n = 2 * n + 1).
    Остаток от деления 2 * n + 1 на 3 будет равен 1.

    Что мы получим после приписывания 0 и 1 к бинарной записи числа, дающего при делении на 3 остаток 1?
    Добавление 0 приведет к умножению числа на 2 (n = (2 * n + 1) * 2 = 4 * n + 2).
    Остаток от деления такого числа на 3 будет равен 2.
    Добавление 1 приведет к умножению числа на 2 и прибавке 1 (n = (2 * n + 1) * 2 + 1 = 4 * n + 2 + 1).
    Такое число делится на 3. Мы вернулись к исходному состоянию.

    Что мы получим после приписывания 0 и 1 к бинарной записи числа, дающего при делении на 3 остаток 2?
    Добавление 0 приведет к умножению числа на 2 (n = (4 * n + 2) * 2 = 8 * n + 4).
    Остаток от деления такого числа на 3 будет равен 1. Мы вернулись к состоянию, когда остаток равен 1.
    Добавление 1 приведет к умножению числа на 2 и прибавке 1 (n = (4 * n + 2) * 2 + 1 = 8 * n + 5).
    Остаток от деления такого числа на 3 будет равен 2. Мы остались в состоянии, когда остаток равен 2.

    Мы получили детерминированный конечный автомат, который меняет свои состояния
    в зависимости от текущего состояния и входного воздействия.

    Теперь мы можем [построить граф смены состояний](http://ivanzuzak.info/noam/webapps/fsm_simulator/)

    Мы имеем три состояния:
    s0 - остаток равен 0
    s1 - остаток равен 1
    s2 - остаток равен 2

    Начальное состояние:
    s0 - остаток равен 0

    Состояние соответствия строки шаблону:
    s0 - остаток равен 0

    Мы имеем два входных воздействия, представленные символами,
    которые мы приписываем справа к бинарной записи числа:
    0
    1

    #states
    s0
    s1
    s2
    #initial
    s0
    #accepting
    s0
    #alphabet
    0
    1
    #transitions
    s0:0>s0
    s0:1>s1
    s1:0>s2
    s1:1>s0
    s2:0>s1
    s2:1>s2

    [Напишем регулярное выражение, соответствующее данному автомату.]
    (https://stackoverflow.com/questions/7974655/regex-for-binary-multiple-of-3/19608040#19608040)

    r'^0*$' - строка из любого количества нулей (находимся в состоянии 0 приписыванием 0 справа)
    r'^0*(11)*0*$' - включаем переход в состояние 1 и возврат из него любое количество раз
    r'^0*(1(01*0)*1)*0*$' - включаем переход в состояние 2 и возврат из него любое количество раз
    r'^(0*(1(01*0)*1)*0*)*$' - учитываем, что процесс может повториться много раз
    r'^(0|1(01*0)*1)*$' - упрощаем выражение, иначе задача не проходит по лимиту времени -
    в состоянии 0 можно оставаться, подавая на вход 0 любое количество раз
    или ходить в состояние 1 любое количество раз. Поход в состояние 1 описывает выражение 1(01*0)*1.
    """
    pattern = re.compile(r'^(0|1(01*0)*1)*$')
    for line in sys.stdin:
        if line == '\n':
            return
        line = line.strip()
        if pattern.match(line):
            print(line)


if __name__ == '__main__':
    main()
